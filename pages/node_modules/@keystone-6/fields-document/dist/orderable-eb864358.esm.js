import _extends from '@babel/runtime/helpers/esm/extends';
import _objectSpread from '@babel/runtime/helpers/esm/objectSpread2';
import _objectWithoutProperties from '@babel/runtime/helpers/esm/objectWithoutProperties';
import { useTheme, jsx, Portal, forwardRefWithAs, Box } from '@keystone-ui/core';
import { forwardRef, createContext, useContext, useRef, useEffect, useCallback, useMemo } from 'react';
import { useSensors, useSensor, MouseSensor, TouchSensor, KeyboardSensor, DndContext, closestCenter } from '@dnd-kit/core';
import { sortableKeyboardCoordinates, arrayMove, SortableContext, verticalListSortingStrategy, useSortable } from '@dnd-kit/sortable';
import { restrictToVerticalAxis } from '@dnd-kit/modifiers';
import { Button } from '@keystone-ui/button';
import { Trash2Icon } from '@keystone-ui/icons/icons/Trash2Icon';

const _excluded$1 = ["isRelative"];
const InlineDialog = /*#__PURE__*/forwardRef((_ref, ref) => {
  let {
    isRelative
  } = _ref,
      props = _objectWithoutProperties(_ref, _excluded$1);

  const {
    radii,
    spacing
  } = useTheme();
  const relativeStyles = isRelative ? {
    left: '50%',
    margin: spacing.small,
    transform: 'translateX(-50%)'
  } : {};
  let dialog = jsx("div", _extends({
    ref: ref,
    contentEditable: false,
    css: _objectSpread({
      background: 'white',
      borderRadius: radii.small,
      boxShadow: `rgba(9, 30, 66, 0.31) 0px 0px 1px, rgba(9, 30, 66, 0.25) 0px 4px 8px -2px`,
      padding: spacing.small,
      position: 'absolute',
      userSelect: 'none'
    }, relativeStyles)
  }, props));

  if (isRelative) {
    return dialog;
  }

  return jsx(Portal, null, dialog);
});

const _excluded = ["children", "direction"],
      _excluded2 = ["as", "isDisabled", "isPressed", "isSelected", "variant"];
// ------------------------------

const ToolbarSpacer = () => {
  const {
    spacing
  } = useTheme();
  return jsx("span", {
    css: {
      display: 'inline-block',
      width: spacing.large
    }
  });
};
const ToolbarSeparator = () => {
  const {
    colors,
    spacing
  } = useTheme();
  return jsx("span", {
    css: {
      alignSelf: 'stretch',
      background: colors.border,
      display: 'inline-block',
      marginLeft: spacing.xsmall,
      marginRight: spacing.xsmall,
      width: 1
    }
  });
}; // Groups
// ------------------------------

const directionToAlignment = {
  row: 'center',
  column: 'start'
};
const ToolbarGroupContext = /*#__PURE__*/createContext({
  direction: 'row'
});

const useToolbarGroupContext = () => useContext(ToolbarGroupContext);

const ToolbarGroup = forwardRefWithAs((_ref, ref) => {
  let {
    children,
    direction = 'row'
  } = _ref,
      props = _objectWithoutProperties(_ref, _excluded);

  const {
    spacing
  } = useTheme();
  return jsx(ToolbarGroupContext.Provider, {
    value: {
      direction
    }
  }, jsx(Box, _extends({
    ref: ref,
    css: {
      display: 'flex',
      gap: spacing.xxsmall,
      flexDirection: direction,
      justifyContent: 'start',
      alignItems: directionToAlignment[direction],
      height: '100%'
    }
  }, props), children));
}); // Buttons
// ------------------------------

const ToolbarButton = forwardRefWithAs(function ToolbarButton(_ref2, ref) {
  let {
    as: Tag = 'button',
    isDisabled,
    isPressed,
    isSelected,
    variant = 'default'
  } = _ref2,
      props = _objectWithoutProperties(_ref2, _excluded2);

  const extraProps = {};
  const {
    direction: groupDirection
  } = useToolbarGroupContext();
  const {
    colors,
    palette,
    radii,
    sizing,
    spacing,
    typography
  } = useTheme();

  if (Tag === 'button') {
    extraProps.type = 'button';
  }

  const variants = {
    default: {
      bgHover: palette.neutral200,
      bgActive: palette.neutral300,
      fg: palette.neutral800
    },
    action: {
      bgHover: palette.blue50,
      bgActive: palette.blue100,
      fg: palette.blue600
    },
    destructive: {
      bgHover: palette.red50,
      bgActive: palette.red100,
      fg: palette.red600
    }
  };
  const style = variants[variant];
  return jsx(Tag, _extends({}, extraProps, {
    ref: ref,
    disabled: isDisabled,
    "data-pressed": isPressed,
    "data-selected": isSelected,
    "data-display-mode": groupDirection,
    css: {
      alignItems: 'center',
      background: 0,
      border: 0,
      borderRadius: radii.xsmall,
      color: style.fg,
      cursor: 'pointer',
      display: 'flex',
      fontSize: typography.fontSize.small,
      fontWeight: typography.fontWeight.medium,
      height: sizing.medium,
      whiteSpace: 'nowrap',
      ':hover': {
        background: style.bgHover
      },
      ':active': {
        background: style.bgActive
      },
      '&:disabled': {
        color: colors.foregroundDisabled,
        pointerEvents: 'none'
      },
      '&[data-pressed=true]': {
        background: style.bgActive
      },
      '&[data-selected=true]': {
        background: colors.foregroundMuted,
        color: colors.background
      },
      // alternate styles within button group
      '&[data-display-mode=row]': {
        paddingLeft: spacing.small,
        paddingRight: spacing.small
      },
      '&[data-display-mode=column]': {
        paddingLeft: spacing.medium,
        paddingRight: spacing.medium,
        width: '100%'
      }
    }
  }, props));
});
function KeyboardInTooltip(_ref3) {
  let {
    children
  } = _ref3;
  const theme = useTheme();
  return jsx("kbd", {
    css: {
      margin: 2,
      padding: theme.spacing.xxsmall,
      fontFamily: 'inherit',
      backgroundColor: theme.colors.foreground,
      borderRadius: theme.radii.xsmall,
      color: theme.colors.background,
      whiteSpace: 'pre'
    }
  }, children);
}

const RemoveContext = /*#__PURE__*/createContext(null);
function OrderableList(props) {
  const sensors = useSensors(useSensor(MouseSensor, {
    activationConstraint: {
      distance: 3
    }
  }), useSensor(TouchSensor), useSensor(KeyboardSensor, {
    coordinateGetter: sortableKeyboardCoordinates
  }));
  const elementsRef = useRef(props.elements);
  useEffect(() => {
    elementsRef.current = props.elements;
  });
  const {
    onChange
  } = props;
  const onRemove = useCallback(index => {
    onChange(elementsRef.current.filter((_, i) => i !== index).map(x => ({
      key: x.key
    })));
  }, [onChange]);
  return jsx(RemoveContext.Provider, {
    value: onRemove
  }, jsx(DndContext, {
    sensors: sensors,
    collisionDetection: closestCenter,
    modifiers: [restrictToVerticalAxis],
    onDragEnd: _ref => {
      let {
        over,
        active
      } = _ref;

      if (over && over.id !== active.id) {
        const activeIndex = props.elements.findIndex(x => (typeof x === 'string' ? x : x.key) === active.id);
        const overIndex = props.elements.findIndex(x => (typeof x === 'string' ? x : x.key) === over.id);
        const newValue = arrayMove(props.elements, activeIndex, overIndex);
        props.onChange(newValue);
      }
    }
  }, jsx(SortableContext, {
    items: useMemo(() => props.elements.map(x => x.key), [props.elements]),
    strategy: verticalListSortingStrategy
  }, jsx("ul", {
    css: {
      isolation: 'isolate',
      display: 'flex',
      gap: 8,
      flexDirection: 'column',
      padding: 0,
      margin: 0
    }
  }, props.children))));
}
const DragHandleListenersContext = /*#__PURE__*/createContext(null);
function OrderableItem(props) {
  var _transform$x, _transform$y;

  const {
    attributes,
    isDragging,
    listeners,
    setNodeRef,
    transform,
    transition,
    index
  } = useSortable({
    id: props.elementKey
  });
  const style = {
    transition,
    zIndex: isDragging ? 2 : 1,
    '--translate-x': `${Math.round((_transform$x = transform === null || transform === void 0 ? void 0 : transform.x) !== null && _transform$x !== void 0 ? _transform$x : 0)}px`,
    '--translate-y': `${Math.round((_transform$y = transform === null || transform === void 0 ? void 0 : transform.y) !== null && _transform$y !== void 0 ? _transform$y : 0)}px`,
    cursor: isDragging ? 'grabbing' : undefined
  };
  return jsx(DragHandleListenersContext.Provider, {
    value: useMemo(() => {
      return {
        attributes,
        listeners,
        isDragging,
        index
      };
    }, [attributes, listeners, isDragging, index])
  }, jsx("li", {
    ref: setNodeRef,
    css: {
      transform: `translateX(var(--translate-x, 0)) translateY(var(--translate-y, 0))`,
      listStyle: 'none'
    },
    style: style
  }, jsx("div", {
    style: {
      pointerEvents: isDragging ? 'none' : undefined,
      transform: `scale(${isDragging ? '1.02' : '1'})`,
      border: '1px solid #DFDFE7'
    },
    css: {
      backgroundColor: 'white',
      borderRadius: 8,
      padding: '8px',
      transition: 'transform 100ms ease, box-shadow 150ms ease'
    }
  }, props.children)));
}
function RemoveButton() {
  const sortable = useContext(DragHandleListenersContext);
  const onRemove = useContext(RemoveContext);

  if (sortable === null || onRemove === null) {
    throw new Error('Must use OrderableItem above RemoveButton');
  }

  return jsx(Button, {
    size: "small",
    weight: "none",
    css: {
      padding: 7
    },
    onClick: () => onRemove(sortable.index),
    "aria-label": "Remove"
  }, jsx(Trash2Icon, {
    size: "small"
  }));
}
function DragHandle() {
  const sortable = useContext(DragHandleListenersContext);

  if (sortable === null) {
    throw new Error('Must use OrderableItem above DragHandle');
  }

  return jsx(Button, _extends({}, sortable.attributes, sortable.listeners, {
    css: {
      cursor: sortable.isDragging ? 'grabbing' : undefined,
      padding: 7
    },
    weight: "none",
    size: "small",
    "aria-label": "Drag handle"
  }), dragIcon);
}
const dragIcon = jsx("span", {
  css: {
    display: 'flex',
    justifyContent: 'center',
    alignItems: 'center'
  }
}, jsx("svg", {
  width: "20",
  height: "21",
  xmlns: "http://www.w3.org/2000/svg"
}, jsx("path", {
  d: "M6 4h3v3H6V4Zm5 0h3v3h-3V4ZM9 9H6v3h3V9Zm2 0h3v3h-3V9Zm-2 5H6v3h3v-3Zm2 0h3v3h-3v-3Z",
  fill: "currentColor"
})));

export { DragHandle as D, InlineDialog as I, KeyboardInTooltip as K, OrderableList as O, RemoveButton as R, ToolbarGroup as T, OrderableItem as a, ToolbarButton as b, ToolbarSeparator as c, ToolbarSpacer as d };
