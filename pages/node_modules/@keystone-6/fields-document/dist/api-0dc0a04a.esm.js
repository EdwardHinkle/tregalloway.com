import _extends from '@babel/runtime/helpers/esm/extends';
import _objectWithoutProperties from '@babel/runtime/helpers/esm/objectWithoutProperties';
import { jsx } from '@keystone-ui/core';
import { FieldContainer, FieldLabel, TextInput, Select, MultiSelect, Checkbox } from '@keystone-ui/fields';
import { useState } from 'react';
import { sanitizeUrl } from '@braintree/sanitize-url';

function isValidURL(url) {
  return url === sanitizeUrl(url);
}

const _excluded = ["children"];
const fields = {
  text(_ref) {
    let {
      label,
      defaultValue = ''
    } = _ref;
    return {
      kind: 'form',

      Input(_ref2) {
        let {
          value,
          onChange,
          autoFocus
        } = _ref2;
        return jsx(FieldContainer, null, jsx(FieldLabel, null, label), jsx(TextInput, {
          autoFocus: autoFocus,
          value: value,
          onChange: event => {
            onChange(event.target.value);
          }
        }));
      },

      options: undefined,
      defaultValue,

      validate(value) {
        return typeof value === 'string';
      }

    };
  },

  url(_ref3) {
    let {
      label,
      defaultValue = ''
    } = _ref3;

    const validate = value => {
      return typeof value === 'string' && (value === '' || isValidURL(value));
    };

    return {
      kind: 'form',

      Input(_ref4) {
        let {
          value,
          onChange,
          autoFocus,
          forceValidation
        } = _ref4;
        const [blurred, setBlurred] = useState(false);
        const showValidation = forceValidation || blurred && !validate(value);
        return jsx(FieldContainer, null, jsx(FieldLabel, null, label), jsx(TextInput, {
          onBlur: () => {
            setBlurred(true);
          },
          autoFocus: autoFocus,
          value: value,
          onChange: event => {
            onChange(event.target.value);
          }
        }), showValidation && jsx("span", {
          css: {
            color: 'red'
          }
        }, "Please provide a valid URL"));
      },

      options: undefined,
      defaultValue,
      validate
    };
  },

  select(_ref5) {
    let {
      label,
      options,
      defaultValue
    } = _ref5;
    const optionValuesSet = new Set(options.map(x => x.value));

    if (!optionValuesSet.has(defaultValue)) {
      throw new Error(`A defaultValue of ${defaultValue} was provided to a select field but it does not match the value of one of the options provided`);
    }

    return {
      kind: 'form',

      Input(_ref6) {
        let {
          value,
          onChange,
          autoFocus
        } = _ref6;
        return jsx(FieldContainer, null, jsx(FieldLabel, null, label), jsx(Select, {
          autoFocus: autoFocus,
          value: options.find(option => option.value === value) || null,
          onChange: option => {
            if (option) {
              onChange(option.value);
            }
          },
          options: options
        }));
      },

      options,
      defaultValue,

      validate(value) {
        return typeof value === 'string' && optionValuesSet.has(value);
      }

    };
  },

  multiselect(_ref7) {
    let {
      label,
      options,
      defaultValue
    } = _ref7;
    const valuesToOption = new Map(options.map(x => [x.value, x]));
    return {
      kind: 'form',

      Input(_ref8) {
        let {
          value,
          onChange,
          autoFocus
        } = _ref8;
        return jsx(FieldContainer, null, jsx(FieldLabel, null, label), jsx(MultiSelect, {
          autoFocus: autoFocus,
          value: value.map(x => valuesToOption.get(x)),
          options: options,
          onChange: options => {
            onChange(options.map(x => x.value));
          }
        }));
      },

      options,
      defaultValue,

      validate(value) {
        return Array.isArray(value) && value.every(value => typeof value === 'string' && valuesToOption.has(value));
      }

    };
  },

  checkbox(_ref9) {
    let {
      label,
      defaultValue = false
    } = _ref9;
    return {
      kind: 'form',

      Input(_ref10) {
        let {
          value,
          onChange,
          autoFocus
        } = _ref10;
        return jsx(FieldContainer, null, jsx(Checkbox, {
          checked: value,
          autoFocus: autoFocus,
          onChange: event => {
            onChange(event.target.checked);
          }
        }, label));
      },

      options: undefined,
      defaultValue,

      validate(value) {
        return typeof value === 'boolean';
      }

    };
  },

  empty() {
    return {
      kind: 'form',

      Input() {
        return null;
      },

      options: undefined,
      defaultValue: null,

      validate(value) {
        return value === null || value === undefined;
      }

    };
  },

  child(options) {
    return {
      kind: 'child',
      options: options.kind === 'block' ? {
        kind: 'block',
        placeholder: options.placeholder,
        dividers: options.dividers,
        formatting: options.formatting === 'inherit' ? {
          blockTypes: 'inherit',
          headingLevels: 'inherit',
          inlineMarks: 'inherit',
          listTypes: 'inherit',
          alignment: 'inherit',
          softBreaks: 'inherit'
        } : options.formatting,
        links: options.links,
        relationships: options.relationships
      } : {
        kind: 'inline',
        placeholder: options.placeholder,
        formatting: options.formatting === 'inherit' ? {
          inlineMarks: 'inherit',
          softBreaks: 'inherit'
        } : options.formatting,
        links: options.links,
        relationships: options.relationships
      }
    };
  },

  object(fields) {
    return {
      kind: 'object',
      fields
    };
  },

  conditional(discriminant, values) {
    if ((discriminant.validate('true') || discriminant.validate('false')) && (discriminant.validate(true) || discriminant.validate(false))) {
      throw new Error('The discriminant of a conditional field only supports string values, or boolean values, not both.');
    }

    return {
      kind: 'conditional',
      discriminant,
      values: values
    };
  },

  relationship(_ref11) {
    let {
      listKey,
      selection,
      label,
      many
    } = _ref11;
    return {
      kind: 'relationship',
      listKey,
      selection,
      label,
      many: many ? true : false
    };
  },

  array(element) {
    return {
      kind: 'array',
      element
    };
  }

};
function component(options) {
  return options;
}
const NotEditable = _ref12 => {
  let {
    children
  } = _ref12,
      props = _objectWithoutProperties(_ref12, _excluded);

  return jsx("span", _extends({
    css: {
      userSelect: 'none'
    },
    contentEditable: false
  }, props), children);
};

export { NotEditable as N, component as c, fields as f, isValidURL as i };
