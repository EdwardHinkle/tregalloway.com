/** @jsxRuntime classic */
/** @jsx jsx */
import { jsx } from '@keystone-ui/core';
import { HTMLAttributes, ReactElement, ReactNode } from 'react';
export declare type FormFieldValue = string | number | boolean | null | readonly FormFieldValue[] | {
    [key: string]: FormFieldValue | undefined;
};
export declare type FormField<Value extends FormFieldValue, Options> = {
    kind: 'form';
    Input(props: {
        value: Value;
        onChange(value: Value): void;
        autoFocus: boolean;
        /**
         * This will be true when validate has returned false and the user has attempted to close the form
         * or when the form is open and they attempt to save the item
         */
        forceValidation: boolean;
    }): ReactElement | null;
    /**
     * The options are config about the field that are available on the
     * preview props when rendering the toolbar and preview component
     */
    options: Options;
    defaultValue: Value;
    /**
     * validate will be called in two cases:
     * - on the client in the editor when a user is changing the value.
     *   Returning `false` will block closing the form
     *   and saving the item.
     * - on the server when a change is received before allowing it to be saved
     *   if `true` is returned
     * @param value The value of the form field. You should NOT trust
     * this value to be of the correct type because it could come from
     * a potentially malicious client
     */
    validate(value: unknown): boolean;
};
declare type InlineMarksConfig = 'inherit' | {
    bold?: 'inherit';
    code?: 'inherit';
    italic?: 'inherit';
    strikethrough?: 'inherit';
    underline?: 'inherit';
    keyboard?: 'inherit';
    subscript?: 'inherit';
    superscript?: 'inherit';
};
declare type BlockFormattingConfig = {
    alignment?: 'inherit';
    blockTypes?: 'inherit';
    headingLevels?: 'inherit' | (1 | 2 | 3 | 4 | 5 | 6)[];
    inlineMarks?: InlineMarksConfig;
    listTypes?: 'inherit';
    softBreaks?: 'inherit';
};
export declare type ChildField = {
    kind: 'child';
    options: {
        kind: 'block';
        placeholder: string;
        formatting?: BlockFormattingConfig;
        dividers?: 'inherit';
        links?: 'inherit';
        relationships?: 'inherit';
    } | {
        kind: 'inline';
        placeholder: string;
        formatting?: {
            inlineMarks?: InlineMarksConfig;
            softBreaks?: 'inherit';
        };
        links?: 'inherit';
        relationships?: 'inherit';
    };
};
export declare type ArrayField<ElementField extends ComponentSchema> = {
    kind: 'array';
    element: ElementField;
};
export declare type RelationshipField<Many extends boolean> = {
    kind: 'relationship';
    listKey: string;
    selection: string | undefined;
    label: string;
    many: Many;
};
export interface ObjectField<Fields extends Record<string, ComponentSchema> = Record<string, ComponentSchema>> {
    kind: 'object';
    fields: Fields;
}
export declare type ConditionalField<DiscriminantField extends FormField<string | boolean, any>, ConditionalValues extends {
    [Key in `${DiscriminantField['defaultValue']}`]: ComponentSchema;
}> = {
    kind: 'conditional';
    discriminant: DiscriminantField;
    values: ConditionalValues;
};
export declare type ComponentSchema = ChildField | FormField<any, any> | ObjectField | ConditionalField<FormField<any, any>, {
    [key: string]: ComponentSchema;
}> | RelationshipField<boolean> | {
    kind: 'array';
    element: ComponentSchema;
};
export declare const fields: {
    text({ label, defaultValue, }: {
        label: string;
        defaultValue?: string | undefined;
    }): FormField<string, undefined>;
    url({ label, defaultValue, }: {
        label: string;
        defaultValue?: string | undefined;
    }): FormField<string, undefined>;
    select<Option extends {
        label: string;
        value: string;
    }>({ label, options, defaultValue, }: {
        label: string;
        options: readonly Option[];
        defaultValue: Option["value"];
    }): FormField<Option["value"], readonly Option[]>;
    multiselect<Option_1 extends {
        label: string;
        value: string;
    }>({ label, options, defaultValue, }: {
        label: string;
        options: readonly Option_1[];
        defaultValue: readonly Option_1["value"][];
    }): FormField<readonly Option_1["value"][], readonly Option_1[]>;
    checkbox({ label, defaultValue, }: {
        label: string;
        defaultValue?: boolean | undefined;
    }): FormField<boolean, undefined>;
    empty(): FormField<null, undefined>;
    child(options: {
        kind: 'block';
        placeholder: string;
        formatting?: BlockFormattingConfig | 'inherit';
        dividers?: 'inherit';
        links?: 'inherit';
        relationships?: 'inherit';
    } | {
        kind: 'inline';
        placeholder: string;
        formatting?: 'inherit' | {
            inlineMarks?: InlineMarksConfig;
            softBreaks?: 'inherit';
        };
        links?: 'inherit';
        relationships?: 'inherit';
    }): ChildField;
    object<Fields extends Record<string, ComponentSchema>>(fields: Fields): ObjectField<Fields>;
    conditional<DiscriminantField extends FormField<string | boolean, any>, ConditionalValues extends { [Key in `${DiscriminantField["defaultValue"]}`]: ComponentSchema; }>(discriminant: DiscriminantField, values: ConditionalValues): ConditionalField<DiscriminantField, ConditionalValues>;
    relationship<Many extends boolean | undefined = false>({ listKey, selection, label, many, }: {
        listKey: string;
        label: string;
        selection?: string | undefined;
    } & (Many extends false | undefined ? {
        many?: Many | undefined;
    } : {
        many: Many;
    })): RelationshipField<Many extends true ? true : false>;
    array<ElementField extends ComponentSchema>(element: ElementField): ArrayField<ElementField>;
};
export declare type ComponentBlock<Fields extends Record<string, ComponentSchema> = Record<string, ComponentSchema>> = {
    preview: (props: any) => ReactElement | null;
    schema: Fields;
    label: string;
} & ({
    chromeless: true;
    toolbar?: (props: {
        props: Record<string, any>;
        onRemove(): void;
    }) => ReactElement;
} | {
    chromeless?: false;
    toolbar?: (props: {
        props: Record<string, any>;
        onShowEditMode(): void;
        onRemove(): void;
        isValid: boolean;
    }) => ReactElement;
});
export declare type GenericPreviewProps<Schema extends ComponentSchema, ChildFieldElement> = Schema extends ChildField ? {
    readonly element: ChildFieldElement;
    readonly schema: Schema;
} : Schema extends FormField<infer Value, infer Options> ? {
    readonly value: Value;
    onChange(value: Value): void;
    readonly options: Options;
    readonly schema: Schema;
} : Schema extends ObjectField<infer Value> ? {
    readonly fields: {
        readonly [Key in keyof Value]: GenericPreviewProps<Value[Key], ChildFieldElement>;
    };
    onChange(value: {
        readonly [Key in keyof Value]?: InitialOrUpdateValueFromComponentPropField<Value[Key]>;
    }): void;
    readonly schema: Schema;
} : Schema extends ConditionalField<infer DiscriminantField, infer Values> ? {
    readonly [Key in keyof Values]: {
        readonly discriminant: DiscriminantStringToDiscriminantValue<DiscriminantField, Key>;
        onChange<Discriminant extends DiscriminantField['defaultValue']>(discriminant: Discriminant, value?: InitialOrUpdateValueFromComponentPropField<Values[`${Discriminant}`]>): void;
        readonly options: DiscriminantField['options'];
        readonly value: GenericPreviewProps<Values[Key], ChildFieldElement>;
        readonly schema: Schema;
    };
}[keyof Values] : Schema extends RelationshipField<infer Many> ? {
    readonly value: Many extends true ? readonly HydratedRelationshipData[] : HydratedRelationshipData | null;
    onChange(relationshipData: Many extends true ? readonly HydratedRelationshipData[] : HydratedRelationshipData | null): void;
    readonly schema: Schema;
} : Schema extends ArrayField<infer ElementField> ? {
    readonly elements: readonly (GenericPreviewProps<ElementField, ChildFieldElement> & {
        readonly key: string;
    })[];
    readonly onChange: (value: readonly {
        key: string | undefined;
        value?: InitialOrUpdateValueFromComponentPropField<ElementField>;
    }[]) => void;
    readonly schema: Schema;
} : never;
export declare type PreviewProps<Schema extends ComponentSchema> = GenericPreviewProps<Schema, ReactNode>;
export declare type InitialOrUpdateValueFromComponentPropField<Schema extends ComponentSchema> = Schema extends ChildField ? undefined : Schema extends FormField<infer Value, any> ? Value | undefined : Schema extends ObjectField<infer Value> ? {
    readonly [Key in keyof Value]?: InitialOrUpdateValueFromComponentPropField<Value[Key]>;
} : Schema extends ConditionalField<infer DiscriminantField, infer Values> ? {
    readonly [Key in keyof Values]: {
        readonly discriminant: DiscriminantStringToDiscriminantValue<DiscriminantField, Key>;
        readonly value?: InitialOrUpdateValueFromComponentPropField<Values[Key]>;
    };
}[keyof Values] : Schema extends RelationshipField<infer Many> ? Many extends true ? readonly HydratedRelationshipData[] : HydratedRelationshipData | null : Schema extends ArrayField<infer ElementField> ? readonly {
    key: string | undefined;
    value?: InitialOrUpdateValueFromComponentPropField<ElementField>;
}[] : never;
declare type DiscriminantStringToDiscriminantValue<DiscriminantField extends FormField<any, any>, DiscriminantString extends PropertyKey> = DiscriminantField['defaultValue'] extends boolean ? 'true' extends DiscriminantString ? true : 'false' extends DiscriminantString ? false : never : DiscriminantString;
export declare type PreviewPropsForToolbar<Schema extends ComponentSchema> = GenericPreviewProps<Schema, undefined>;
export declare type HydratedRelationshipData = {
    id: string;
    label: string;
    data: Record<string, any>;
};
export declare type RelationshipData = {
    id: string;
    label: string | undefined;
    data: Record<string, any> | undefined;
};
export declare function component<Schema extends {
    [Key in any]: ComponentSchema;
}>(options: {
    /** The preview component shown in the editor */
    preview: (props: PreviewProps<ObjectField<Schema>>) => ReactElement | null;
    /** The schema for the props that the preview component, toolbar and rendered component will receive */
    schema: Schema;
    /** The label to show in the insert menu and chrome around the block if chromeless is false */
    label: string;
} & ({
    chromeless: true;
    toolbar?: (props: {
        props: PreviewPropsForToolbar<ObjectField<Schema>>;
        onRemove(): void;
    }) => ReactElement;
} | {
    chromeless?: false;
    toolbar?: (props: {
        props: PreviewPropsForToolbar<ObjectField<Schema>>;
        onShowEditMode(): void;
        onRemove(): void;
    }) => ReactElement;
})): ComponentBlock<Schema>;
export declare const NotEditable: ({ children, ...props }: HTMLAttributes<HTMLDivElement>) => jsx.JSX.Element;
declare type Comp<Props> = (props: Props) => ReactElement | null;
declare type ValueForRenderingFromComponentPropField<Schema extends ComponentSchema> = Schema extends ChildField ? ReactNode : Schema extends FormField<infer Value, any> ? Value : Schema extends ObjectField<infer Value> ? {
    readonly [Key in keyof Value]: ValueForRenderingFromComponentPropField<Value[Key]>;
} : Schema extends ConditionalField<infer DiscriminantField, infer Values> ? {
    readonly [Key in keyof Values]: {
        readonly discriminant: DiscriminantStringToDiscriminantValue<DiscriminantField, Key>;
        readonly value: ValueForRenderingFromComponentPropField<Values[Key]>;
    };
}[keyof Values] : Schema extends RelationshipField<infer Many> ? Many extends true ? readonly HydratedRelationshipData[] : HydratedRelationshipData | null : Schema extends ArrayField<infer ElementField> ? readonly ValueForRenderingFromComponentPropField<ElementField>[] : never;
export declare type ValueForComponentSchema<Schema extends ComponentSchema> = Schema extends ChildField ? null : Schema extends FormField<infer Value, any> ? Value : Schema extends ObjectField<infer Value> ? {
    readonly [Key in keyof Value]: ValueForRenderingFromComponentPropField<Value[Key]>;
} : Schema extends ConditionalField<infer DiscriminantField, infer Values> ? {
    readonly [Key in keyof Values]: {
        readonly discriminant: DiscriminantStringToDiscriminantValue<DiscriminantField, Key>;
        readonly value: ValueForRenderingFromComponentPropField<Values[Key]>;
    };
}[keyof Values] : Schema extends RelationshipField<infer Many> ? Many extends true ? readonly HydratedRelationshipData[] : HydratedRelationshipData | null : Schema extends ArrayField<infer ElementField> ? readonly ValueForRenderingFromComponentPropField<ElementField>[] : never;
declare type ExtractPropsForPropsForRendering<Props extends Record<string, ComponentSchema>> = {
    readonly [Key in keyof Props]: ValueForRenderingFromComponentPropField<Props[Key]>;
};
export declare type InferRenderersForComponentBlocks<ComponentBlocks extends Record<string, ComponentBlock<any>>> = {
    [Key in keyof ComponentBlocks]: Comp<ExtractPropsForPropsForRendering<ComponentBlocks[Key]['schema']>>;
};
export {};
